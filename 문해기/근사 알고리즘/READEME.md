# 근사 알고리즘 (Approximation Algorithm)
* 근사해가 최적해에 얼마나 근사한지를 나타내는 <strong>근사 비율(approximation ratio)</strong>을 보여주어야 한다(1.0에 가까울수록 정확도가 높음)

### ◎외판원 문제(Traveling Salesperson Problem, TSP)
* 어느 한 도시에서 출발하여 다른 모든 도시를 1번씩만 방문하고 출발했던 도시로 돌아오는 여행 경로의 거리를 최소화 하는 문제
* 외판원 문제는 다양한 알고리즘으로 최적해를 찾을 수 있으나 이들은 모두 지수 시간이 걸림
* 따라서 도시 수가 많아지면 시간이 오래 걸려서 최적해를 찾기 점점 어려워진다
```
<TSP 근사 알고리즘>
[1] 입력 그래프에서 MST T를 찾는다
[2] T의 시작점에서 트리의 간선을 따라 모든 점을 방문하고 다시 시작점으로 방문 순서를 찾는다
[3] [2]에서 찾은 방문 순서에서 중복된 점들을 제거, 마지막의 시작점은 제거x
== 수행시간 : 방문순서를 찾는 시간 O(n), 반복되는 점의 제거도 O(n)소요 => O(n) + O(n) = O(n)==
```
```
<TSP 근사 알고리즘 구현>
def dfs(v):
    visited[v] = True
    path.append(v)      #처음 방문할 때 경로에 추가
    for w in tree[v]:
        if not visited[w]:
            dfs(w)      #v에 인접한 w로 순환 호출
            path.append(v)  #되돌아 나올때 경로에 추가
            
for vertex in path:
    if vertex not in s:     #중복 방문 제거
        s.append(vertex)
```
* 근사 비율을 구해보자
  * MST간선의 가중치의 합(M)을 활용, 다 돌고 오는거 -> 2M보다 크지 않음
  * 따라서 근사 비율은 2M/M = 2.0보다 크지 않다. 즉 근사해는 최적해의 2배를 넘지 않는다

<br>

### ◎집합 커버(Set Cover)
* n개의 원소(숫자)를 가진 집합 U가 있고, U의 부분 집합들을 원소로 하는 집합 F가 있을때, F의 원소들 중에서
어떤 원소들을 선택하여 합집합하면 U와 같은가?
* F에서 선택하는 집합들의 수를 최소화하는 문제

#### 학교 건설
* 10개의 마을이 있는 신도시에 학교를 다음 두가지 조건이 만족되도록 만들어야함
  * 학교는 마을에 위치해야한다
  * 등교거리는 걸어서 15분 이내이어야 한다
```
<집합 커버 알고리즘>
[1] C = []
[2] while U가 empty가 아니면:      #O(n)
        U의 원소들을 가장 많이 포함하고 있는 집합 Si를 F에서 선택    #O(n) => O(n²)
        U = U -Si       #O(n)
        Si의 원소를 다른 집합에서 제거
        Si를 F에서 제거하고, Si를 C에 추가   #O(1)
== 시간 복잡도 : nXO(n²) = O(n³) ==
```
```
<집합 커버 구현>
while len(U) > 0:
  max_cover_set = S.index(max(S, key=lambda x:len(U & x)))
  U = U - S[max_cover_set]
  for i in range(len(U)):
    if i != max_cover_set:
      S[i] = S[i] - S[max_cover_set]
  set_cover.append(max_cover_set)
  S[max_cover_set] = set()
```
* 근사 비율
  * 집합 커버 알고리즘의 근사 비율은 Klnn (최악 경우의 해일지라도 그 집합 수가 Klnn개를 넘지 않는다는 뜻, K는 최적해의 집합 수)
  * 현재 문제에서 최적해가 집합 2개로 모든 마을을 커버했으므로, Klnn = 2xln10 < 2x3 = 6
    * 즉, 집합 커버 알고리즘이 찾은 근사해의 집합 수는 6개를 초과하지 않는다는 것
<br>

### ◎통 채우기(Bin packing)
* n개의 물건이 주어지고, 통의 용량이 C일때, 주어진 모든 물건을 가장 적은 수의 통에 채우는 문제
* 단, 각 물건의 크기는 C보다 크지 않다
* 그리디 방법
  * <strong>최초 적합(First fit)</strong> : 좌에서 우로 통을 살피면서 가장 먼저 담을 수 있는 통에 새 물건을 넣는법
  * <strong>최악 적합(Worst fit)</strong> : 새 물건을 넣을 수 있는 통 중에서 남는 부분이 가장 큰 통에 새 물건을 넣는법
  * <strong>최선 적합(Best fit)</strong> : 새 물건을 넣을 수 있는 통 중에서 남는 부분이 가장 적은 통에 새 물건으 넣는법
  * <strong>다음 적합(Next fit)</strong> : 직전에 물건을 넣은 통에 여유가 있으면 새 물건을 넣는다. 넣을 수 없으면 새 통에 새 물건을 넣는다
```
<통 채우기 알고리즘>
[1] B = 0   #사용된 통의 수
[2] for i = 1 to n:
        if 물건  i를 넣을 여유가 있는 기존의 통이 있으면:   
            그리디 방법에 따라 정해진 통에 물건 i를 넣는다
        else:
            새 통에 물건 i를 넣는다
            B = B + 1   #통의 수를 1증가시킨다
== 다음 적합을 제외한 알고리즘은 새 물건을 넣을 때마다 기존의 통들을 살펴보아야 하기때문에 O(n²),
다음 적합은 새 물건에 대해 직전에 사용된 통만 살펴보기 때문에 물건 1개를 담는데 O(1)소요 즉 O(n)소요== 
```
```
<통 채우기 구현 [최초 적합(First Fit)]>
for i in range(n):    #물건 i를 통에 담기
  j = 0
  packed = False
  while j < bin_count:    #기존에 있는 통 j(번쩨)에 물건 i를 담는 경우
    if item[i] <= remnant[j]:
      bins[j].append([i, item[i]])
      remnant[j] -= item[i]
      packed = True
      break
    j += 1    #다음 통(j+1)번째로
  if not packed:          #새 통에 물건 i를 담는 경우
    bins[j].append([i, item[i]])
    remnant[j] -= item[i]
    bin_count += 1        #통의 수 1증가
```
* 근사 비율
  * 다음 적합을 제외한 알고리즘이 사용하는 통은 2개의상의 통이 1/2이하로 차있으면 이를 1개로 합친다
  * 최적해에서 사용된 통의 수를 OPT라고 하면, OPT >= (모든 물건의 크기의 합)/C (C:통의 크기)
    * (모든 물건의 크기의 합) > (F-1)xC/2
      * => (모든 물건의 크기의 합)/C > (F-1)/2     #양변을 C로 나눈 결과
      * => OPT > (F-1)/2                        #OPT>=(모든 물건의 크기의 합)/C이므로
      * => 2OPT > F-1                           #양변에 2를 곱한 결과
      * => 2OPT + 1 > F                         
      * => 2OPT >= F
    * 따라서 3가지 그리디 알고리즘의 근사 비율은 2.0이다
  * 다음 적합의 근사비율
    * (모든 물건의 크기의 합) > (F/2)xC
      * => (모든 물건의 크기의 합)/C > F/2   #양변을 C로 나눈 결과
      * => OPT > F/2                      #OPT >= (모든 물건의 크기의 합)/C이므로
      * => 2OPT > F
    * 따라서 다음 적합의 근사 비율도 2.0이다

### ◎합이 최대 K 되는 숫자
* 앞에서 동적 계획, 백트래킹 으로 다 해를 찾았는데 이는 입력이 커지면 최적해를 찾기 어려움
* 이를 해결하기위해 수행시간에 상관없이 최적해를 찾는 알고리즘은 Exact algorithm으로 해결
* ε: 근사 알고리즘의 정확도를 나타내는 상수
```
<대표 숫자 구하기 알고리즘>
[1] 리스트 T를 정렬
[2] 대표 숫자 = T[0]  #첫 숫자는 대표 숫자로 정함
[3] for i = 1 to |T| - 1
        if 대표 숫자 < T[i] <= 대표숫자 * (1.0 + δ)
           T[i]를 T에서 제거
        else:
           대표 숫자 = T[i]
    return T 
```
```
<합이 최대 K 되는 숫자 알고리즘>
[1] δ = ε/2n
[2] L = [0]
[3] for i = 1 to n
        L의 각 원소에 Si를 더한 숫자로 리스트 A를 만든다
        A와 L을 합병하여 리스트 T를 만든다
        T에서 중복된 숫자를 하나만 남기고 제거
        대표_숫자_알고리즘(T,δ) 호출
        T에서 K보다 큰 숫자 제거
        L = T
    return 리스트 L에서 가장 큰 숫자 
```