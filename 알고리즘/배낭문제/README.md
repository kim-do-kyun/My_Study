# 배낭 문제
* 각 물품의 무게와 이익이정해져 있는 물품들의 집합 S와 최대 무게 M까지 담을 수 있는 배낭이 주어졌을때 최대 이익을 얻으며 배낭 용량을 초과하지 않으면서 어떤 물품을 담아야 하는가 결정하는문제
  * 분수배낭 문제 : 물품을 분할하여 담는 것이 허용, 탐욕법(그리디)으로 최적해를 얻을 수 잇음
  * 0-1 배낭 문제 : 물품을 분할하여 담는 것이 허용되지 않음, 탐욕법(그리디)으로 최적해를 얻을 수 없으며, 동적계획법이나 백트래킹으로 풀어야함

```
<점화식>
[1-based indexing]
          |               0                     n = 0 or M = 0
K(n, M) = |             K(n-1, M)                    M < w[n]
          | max(K(n-1, M), p[n] + K(n-1, M - w[n]))  M >= w[n]

[0-based indexing]     =알고리즘 수업때 사용=
          |               0                     n = 0 or M = 0
K(n, M) = |             K(n-1, M)                    M < w[n-1]
          | max(K(n-1, M), p[n-1] + K(n-1, M - w[n-1]))  M >= w[n-1]
```

### ◎단순 재귀적 구현
* 입력값에 따라서 중첩 부문제 발생으로 무한루프 걸릴 수 있음
``` 
M,w,p = 70,[1]*50,[1]*50 의 경우 실행x
==시간 복잡도 : O(2ⁿ)==
```

### ◎메모이제이션(Top-down DP)
* 단순 재귀적 구현에서 돌아가지 않는 위의 문제 해결 가능
* 저장 방식
  * 사전 사용 : memo = {}에 추가
  * 리스트 사용 : memo = []에 추가(2차원 배열 형식으로 사용)ㅋ
```
<사전 사용>
==시간 복잡도 : O(min(2ⁿ, nM))==
```
```
<리스트 사용>
(n+1) 행, (M+1) 열의 메모이제이션 저장소를 -1로 초기화
memo[n][M]이 -1이 아닌 경우 : n개의 물품, 용량 M 배낭의 문제가 이미 해결되어있으므로 값이 저장되어있음
==시간 복잡도 : O(nM)==
```
<br>[계산 후 memo]<br>
![스크린샷 2023-11-18 153448](https://github.com/kim-do-kyun/My_Study/assets/70315428/f2e17707-6201-4e57-b24e-a5cca7cd8024) 
```
K(3,5)
 = max( K(2,5), p[2] + K(2, 5-w[2]) )
 = max( K(2,5), 300 + K(2, 5-2) )
 = max( K(2,5), 300 + K(2, 3) )
 = max( 300, 300 + 200)
 = 500
 ```

 ### ◎Bottom-up DP
 * dp 테이블 내 셀에 대응하는 각 배낭 문제 dp[n][M]은 부문제 dp[n-1][M], dp[n-1][M-w[n-1]]의 해로부터 계산, 첫번째 부문제는 dp[n][M]의 직전 행의 동일 열에 위치, 두번째 부문제는 dp[n][M]의 직전 행에서 M보다 작은 번호의 열에 위치
 * 즉 dp테이블 내 셀에 대응하는 각 배낭 문제를 dp테이블 내 위에서 아래로(행 번호 0부터 증가), 왼쪽에서 오른쪽으로(열번호 0부터 증가) 해결하면됨
```==시간복잡도 : O(nM)==```
<br>[계산 후 dp테이블]<br>
![스크린샷 2023-11-18 154611](https://github.com/kim-do-kyun/My_Study/assets/70315428/dcf30974-eb3a-4044-a4d5-59ff86cd6715)

### [정리]

|0/1 배낭문제 구현 방법|시간복잡도|공간복잡도|비고|
|------|--|--|-----|
|재귀적 기법|O(2ⁿ)|재귀호출 O(n)|중첩 부문제 계산시간, 재귀 호출 오버헤드|
|Top-down DP, 배열 저장소|O(nM)|o(nM)|최종 해 관점에서 불필요 공간 할당 시간 소요, 재귀 호출 오버헤드|
|Top-down DP, 사전 저장소|O(min(2ⁿ, nM))|O(min(2ⁿ, nM))|재귀 호출 오버헤드|
|Bottom-up DP|O(nM)|o(nM)|최종 해 관점에서 불필요 공간 할당 시간 및 불필요 부문제 계산 시간|
* O(nM)은 다항시간(polynomial time)인가? M = 2ⁿ인 경우 지수 시간이 소요됨
* 0/1 배낭문제는 NP-hard임, 즉 P=NP가 아니라면 0/1 배낭문제에 대한 다항시간 알고리즘은 불가능함