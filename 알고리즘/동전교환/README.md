# 동전 교환 알고리즘
* 서로 다른 액면가를 갖는 동전들로 구성된 동전시스템에서, 거스름돈 w를 최소 개수 동전으로 거슬러 주는 방법을 찾는 문제
* 탐욕법(그리디)으로 동전교환 문제를 해결하면, 동전 시스템에 따라 최적해를 구할 수도 있고, 최적해를 구하지 못할 수도 있음
* 동적계획법(DP)을 사용하면 항상 최적해를 구할 수 있음

```
<점화식>
            |               0               money = 0
cc(money) = |               ∞               money < 0
            | min(1 + cc(money - coin[i]))  money > 0
```

### ◎단순 재귀적 구현
* 단순 재귀적 구현, 분할 정복
* 거슬러 주는 방법이 존재하지 않을 경우 float('inf') 반환
* 입력값에 따라서 중첩 부문제 발생으로 무한루프 걸릴 수 있음

### ◎메모이제이션(Top-down DP)
* 중첩 부문제들에 대해 최소 한 번만 풀고 그 해를 보관해둔 다음 재사용
* 모든 가능한 부문제를 풀지 않고 필요한 부문제들만 푼다
* 리스트 저장소 사용시 -1로 초기화 후 memo[i]가 -1이 아닌경우 이미 계산된 값이있으므로 그 값을 리턴 하는 형식으로 이전 결과 값을 재사용

### ◎메모이제이션, 최소 개수 동전 정보 출력
* 거스름돈에 대한 최소 개수 동전 정보 출력을 위해, P[money]에 최초 선택해야 할 동전의 액면가 저장
```
#각 동전 한개를 사용한 경우 이전보다 더 적은 최소동전수가 얻어진다면 사용된 동전 액면가를 저장
for i in range(len(coin)):
    new_count = 1 + f(money-coin[i])
    if new_count < count:
        count = new_count
        coinUsed = coin[i]
memo[money] = count
P[money] = coinUsed
```

### ◎Bottom-up DP
* Bottom-up DP는 가장 작은 부문제부터 시작하여 모든 가능한 크기의 부문제를 품
* 특정 크기 부문제 p를 푸는 시점에 p보다 작은 크기의 모든 부문제들은 이미 해결, 그 해는 저장소에 있음
```
# 서로 다른 액면가 동전 개수 c, 거스름돈 M에 대해
# 시간복잡도 O(cM), 공간복잡도 O(M)
```