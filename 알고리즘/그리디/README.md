# Greedy Algorithm
* 최적화(optimization) 문제를 해결하는 문제 방식 중 하나
* 선택 과정에서 모든 데이터를 고려하지 않고 근시안적으로 욕심을 내어 최소(최대)값을 가진 데이터 선택
* 구간 스케줄링, 구간분할, 초 증가순서, 최소 신장 트리, 최단경로, 허프만 코딩

<hr>

### ◎초 증가 순서
* 초 증가 순서(Super Increasing Sequence) : 주어진 숫자들에 대해 각 숫자가 자신보다 앞선 숫자들의 합보다 큰 숫자들
```
입력받은 리스트 정렬 후, 큰수부터 작은 수 순서로 역순으로 실행
리스트의 원소가 K보다 작거나 같으면 결과 값을 저장할 리스트에 추가 
이후 K를 리스트에 저장한 값을 뺀 과정을 K가 0이 될때 까지 반복
==입력에 n개의 숫자가 있어 시간복잡도는 "O(n)"==
```

### ◎최소 신장 트리(Minimum Spanning Tree, MST)
* 트리는 점들이 서로 연결되어 있지만 <strong>사이클</strong>을 가지지 않음
* Spanning Tree(신장트리) : 그래프의 모든 점을 연결하는 트리
* 트리의 특성
  * n개의 점을 가진 그래프의 신장 트리는 n-1개의 간선을 가짐
  * 두 점 사이의 경로는 하나밖에 없다
* 최소 신장 트리(MST) : 간선에 가중치가 부여된 그래프에서 최소 가중치의 합을 가진 신장트리
  * Kruskal 알고리즘
  * Prim 알고리즘
```
<Prim 알고리즘>
임의의 점 하나를 선택하여 T에 넣는다
T 밖에 있는 점 중에서 T에 있는 점과 가장 가까운 점을 T에 추가(이를 n-1회 수행)
==트리에 포함된 정점들을 1회 들어 올릴 때마다 가장 짧게 매달린 점을 찾아야 하므로 최대 O(n)의 시간이 걸림.
따라서 프림 MST 알고리즘의 수행시간은 n X O(n) = O(n²)==
```
